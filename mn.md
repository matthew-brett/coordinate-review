# Output of `rg "\(M\s*,\s*N"`

```
src/skimage/future/manual_segmentation.py:    image : (M, N[, 3]) array
src/skimage/future/manual_segmentation.py:    image : (M, N[, 3]) array
src/skimage/draw/draw.py:    image : ndarray of shape (M, N, C)
src/skimage/draw/draw3d.py:    ellipsoid : (M, N, P) array
src/skimage/graph/_rag.py:    image : ndarray, shape(M, N[, ..., P], 3)
src/skimage/graph/_rag.py:    labels : ndarray, shape(M, N[, ..., P])
src/skimage/graph/_rag.py:        `image`. If `image` has dimensions `(M, N, 3)` `labels` should have
src/skimage/graph/_rag.py:        dimensions `(M, N)`.
src/skimage/graph/_rag.py:    labels : ndarray, shape (M, N)
src/skimage/graph/_rag.py:    image : ndarray, shape (M, N[, 3])
src/skimage/filters/rank/_percentile.py:    image : ndarray of shape (M, N) and dtype (uint8 or uint16)
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N), same dtype as input `image`
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N), same dtype as input `image`
src/skimage/filters/rank/_percentile.py:    image : ndarray of shape (M, N) and dtype (uint8 or uint16)
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N) and dtype int
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N) and dtype int
src/skimage/filters/rank/_percentile.py:    image : ndarray of shape (M, N) and dtype (uint8 or uint16)
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N) and dtype int
src/skimage/filters/rank/_percentile.py:    out : ndarray of shape (M, N) and dtype int
src/skimage/filters/lpi_filter.py:        data : ndarray of shape (M, N)
src/skimage/filters/lpi_filter.py:    data : ndarray of shape (M, N)
src/skimage/filters/lpi_filter.py:    data : ndarray of shape (M, N)
src/skimage/filters/lpi_filter.py:    data : ndarray of shape (M, N)
src/skimage/filters/lpi_filter.py:    K : float or ndarray of shape (M, N)
src/skimage/io/_plugins/matplotlib_plugin.py:    image : array, shape (M, N[, 3])
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/filters/edges.py:    image : ndarray of shape (M, N)
src/skimage/filters/edges.py:    mask : ndarray of shape (M, N), optional
src/skimage/filters/edges.py:    output : ndarray of shape (M, N) and dtype float
src/skimage/segmentation/_watershed.py:    image : (M, N[, ...]) ndarray
src/skimage/segmentation/_watershed.py:    markers : int, or (M, N[, ...]) ndarray of int, optional
src/skimage/segmentation/_watershed.py:    mask : (M, N[, ...]) ndarray of bools or 0's and 1's, optional
src/skimage/segmentation/_chan_vese.py:    image : ndarray of shape (M, N)
src/skimage/segmentation/_chan_vese.py:    init_level_set : str or (M, N) ndarray, optional
src/skimage/segmentation/_chan_vese.py:    segmentation : ndarray of shape (M, N) and dtype bool
src/skimage/segmentation/_chan_vese.py:    phi : ndarray of shape (M, N) and dtype float
src/skimage/filters/thresholding.py:    image : ndarray of shape (M, N)
src/skimage/filters/thresholding.py:    image : ndarray of shape (M, N)
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    threshold : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray, optional
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray, optional
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    threshold : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    threshold : (M, N[, ...]) ndarray
src/skimage/filters/thresholding.py:    image : (M, N[, ...]) ndarray, optional
src/skimage/io/_io.py:    arr : ndarray of shape (M, N[, C]), with C=3 or C=4
src/skimage/segmentation/_quickshift_cy.pyx:    image : (M, N, C) ndarray
src/skimage/segmentation/_quickshift_cy.pyx:    segment_mask : (M, N) ndarray
src/skimage/filters/_sparse.py:    image : ndarray, dtype float, shape (M, N[, ...], P)
src/skimage/filters/_sparse.py:    result : array of float, shape (M, N[, ...], P)
src/skimage/segmentation/morphsnakes.py:    image : (M, N) or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    gimage : (M, N) or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    image : (M, N) or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    init_level_set : str, (M, N) array, or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    out : (M, N) or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    gimage : (M, N) or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    init_level_set : str, (M, N) array, or (L, M, N) array
src/skimage/segmentation/morphsnakes.py:    out : (M, N) or (L, M, N) array
src/skimage/transform/hough_transform.py:    hspace : ndarray, shape (M, N)
src/skimage/transform/hough_transform.py:    image : ndarray, shape (M, N)
src/skimage/transform/hough_transform.py:    image : ndarray of shape (M, N)
src/skimage/transform/hough_transform.py:    image : ndarray of shape (M, N)
src/skimage/transform/hough_transform.py:    image : ndarray, shape (M, N)
src/skimage/transform/hough_transform.py:    hspaces : (M, N, P) array
src/skimage/transform/_warps.py:    image : (M, N[, ...][, C]) ndarray
src/skimage/transform/_warps.py:    a : (M, N) or (M, N, P) ndarray
src/skimage/transform/_warps.py:    b : (M, N)
src/skimage/transform/_warps.py:    Color images are stored as an ``(M, N, 3)`` or ``(M, N, 4)`` arrays.
src/skimage/transform/_warps.py:    image : (M, N[, C]) ndarray
src/skimage/segmentation/active_contour_model.py:    image : ndarray of shape (M, N[, 3])
src/skimage/transform/radon_transform.py:    radon_image : ndarray, shape (M, N)
src/skimage/filters/ridges.py:    image : (M, N[, ...]) ndarray
src/skimage/filters/ridges.py:    out : (M, N[, ...]) ndarray
src/skimage/filters/ridges.py:    image : (M, N[, P]) ndarray
src/skimage/filters/ridges.py:    out : (M, N[, P]) ndarray
src/skimage/filters/ridges.py:    image : (M, N[, P]) ndarray
src/skimage/filters/ridges.py:    out : (M, N[, P]) ndarray
src/skimage/filters/ridges.py:    image : (M, N[, P]) ndarray
src/skimage/filters/ridges.py:    out : (M, N[, P]) ndarray
src/skimage/segmentation/slic_superpixels.py:    image : (M, N[, P][, C]) ndarray
src/skimage/segmentation/slic_superpixels.py:    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To
src/skimage/transform/_radon_transform.pyx:    image : ndarray of float, shape (M, N)
src/skimage/transform/_radon_transform.pyx:    image : ndarray of float, shape (M, N)
src/skimage/transform/_radon_transform.pyx:    image_update : ndarray of float, shape (M, N)
src/skimage/transform/_radon_transform.pyx:    image : ndarray of float, shape (M, N)
src/skimage/transform/_radon_transform.pyx:    image_update : ndarray of float, shape (M, N)
src/skimage/filters/_gabor.py:    image : ndarray of shape (M, N)
src/skimage/filters/_gabor.py:    real, imag : ndarray of shape (M, N)
src/skimage/segmentation/_felzenszwalb_cy.pyx:    image : (M, N, C) ndarray
src/skimage/segmentation/_felzenszwalb_cy.pyx:    segment_mask : (M, N) ndarray
src/skimage/transform/_hough_transform.pyx:    img : (M, N) ndarray
src/skimage/transform/_hough_transform.pyx:    img : (M, N) ndarray
src/skimage/transform/_hough_transform.pyx:    img : (M, N) ndarray
src/skimage/transform/_hough_transform.pyx:    img : (M, N) ndarray
src/skimage/transform/_geometric.py:    src : (M, N) array_like
src/skimage/transform/_geometric.py:    dst : (M, N) array_like
src/skimage/segmentation/_quickshift.py:    image : ndarray of shape (M, N, C)
src/skimage/segmentation/_quickshift.py:    segment_mask : ndarray of shape (M, N) and dtype int
src/skimage/transform/_warps_cy.pyx:    image : ndarray, shape (M, N)
src/skimage/segmentation/_felzenszwalb.py:    image : ndarray of shape (M, N[, 3])
src/skimage/segmentation/_felzenszwalb.py:    segment_mask : ndarray of shape (M, N)
src/skimage/segmentation/random_walker_segmentation.py:    data : (M, N[, P][, C]) ndarray
src/skimage/segmentation/random_walker_segmentation.py:    labels : (M, N[, P]) array of ints
src/skimage/segmentation/boundaries.py:    image : ndarray of shape (M, N[, 3])
src/skimage/segmentation/boundaries.py:    label_img : ndarray of shape (M, N) and dtype int
src/skimage/segmentation/boundaries.py:    marked : ndarray of shape (M, N, 3) and dtype float
src/skimage/util/compare.py:    image0, image1 : ndarray, shape (M, N)
src/skimage/util/compare.py:    comparison : ndarray, shape (M, N)
src/skimage/util/unique.py:    ar : ndarray, shape (M, N)
src/skimage/restoration/_denoise.py:    image : ndarray, shape (M, N[, 3])
src/skimage/restoration/deconvolution.py:    image : ndarray of shape (M, N)
src/skimage/restoration/deconvolution.py:    x_postmean : ndarray of shape (M, N)
src/skimage/registration/_optical_flow.py:    reference_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    moving_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    reference_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    moving_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    reference_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    moving_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    reference_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/registration/_optical_flow.py:    moving_image : ndarray, shape (M, N[, P[, ...]])
src/skimage/feature/_haar.pyx:    int_image : (M, N) ndarray
src/skimage/feature/_daisy.py:    image : (M, N) array
src/skimage/feature/_daisy.py:    descs_img : ndarray of shape (M, N, 3), only if visualize=True
src/skimage/feature/template.py:    image : (M, N[, P]) array
src/skimage/feature/template.py:        is an array with shape `(M - m + 1, N - n + 1)` for an `(M, N)` image
src/skimage/feature/texture.py:    image : (M, N) array
src/skimage/feature/texture.py:    output : (M, N) array
src/skimage/feature/corner.py:        An array of shape ``(M, N[, ...], image.ndim, image.ndim)``,
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : ndarray of shape (M, N)
src/skimage/feature/corner.py:    image : (M, N) array
src/skimage/feature/peak.py:    image : (M, N) ndarray
src/skimage/feature/_hog.py:    channel : ndarray of shape (M, N)
src/skimage/feature/_hog.py:    image : (M, N[, C]) ndarray
src/skimage/feature/_hog.py:    hog_image : (M, N) ndarray, optional
src/skimage/feature/haar.py:    int_image : ndarray of shape (M, N)
src/skimage/feature/haar.py:    image : ndarray of shape (M, N)
src/skimage/feature/haar.py:    features : ndarray of shape (M, N)
src/skimage/morphology/_skeletonize.py:    image : (M, N[, P]) ndarray of bool or int
src/skimage/morphology/_skeletonize.py:    skeleton : (M, N[, P]) ndarray of bool
src/skimage/morphology/_skeletonize.py:    image : binary (M, N) ndarray
src/skimage/morphology/_skeletonize.py:    image : binary ndarray, shape (M, N)
src/skimage/morphology/_skeletonize.py:    mask : binary ndarray, shape (M, N), optional
src/skimage/morphology/convex_hull.py:    gridcoords : ndarray of shape (M, N)
src/skimage/morphology/convex_hull.py:    hull_equations : ndarray of shape (M, N)
src/skimage/morphology/convex_hull.py:    hull : (M, N) array of bool
src/skimage/morphology/convex_hull.py:    image : ndarray of shape (M, N)
CONTRIBUTING.rst:* When documenting array parameters, use ``image : (M, N) ndarray``
src/skimage/measure/entropy.py:    image : ndarray of shape (M, N)
src/skimage/measure/_marching_cubes_lewiner.py:    volume : (M, N, P) ndarray
src/skimage/measure/_marching_cubes_lewiner.py:        indexing dimensions (M, N, P) as in `volume`.
src/skimage/measure/_marching_cubes_lewiner.py:    mask : (M, N, P) array, optional
src/skimage/measure/_marching_cubes_lewiner.py:        matches input `volume` (M, N, P). If ``allow_degenerate`` is set to
src/skimage/measure/_pnpoly.pyx:    shape : tuple (M, N)
src/skimage/measure/_pnpoly.pyx:    mask : (M, N) ndarray of bool
src/skimage/measure/_pnpoly.pyx:         np.zeros((M, N), dtype=np.uint8)
src/skimage/measure/_regionprops_utils.py:    image : (M, N[, P]) ndarray
src/skimage/measure/_regionprops_utils.py:    image : ndarray of shape (M, N)
src/skimage/measure/_regionprops_utils.py:    image : ndarray of shape (M, N)
src/skimage/measure/profile.py:    image : ndarray, shape (M, N[, C])
src/skimage/measure/_find_contours.py:    image : ndarray of shape (M, N) and dtype float
src/skimage/measure/_find_contours.py:    mask : ndarray of shape (M, N) and dtype bool
src/skimage/measure/pnpoly.py:    shape : tuple (M, N)
src/skimage/measure/pnpoly.py:    mask : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    image0 : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    image1 : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    mask : (M, N) ndarray of dtype bool, optional
src/skimage/measure/_colocalization.py:    image0 : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    image1_mask : (M, N) ndarray of dtype bool
src/skimage/measure/_colocalization.py:    mask : (M, N) ndarray of dtype bool, optional
src/skimage/measure/_colocalization.py:    image0 : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    image1 : ndarray of shape (M, N)
src/skimage/measure/_colocalization.py:    mask : ndarray of shape (M, N) and dtype bool, optional
src/skimage/measure/_colocalization.py:    image0_mask : (M, N) ndarray of dtype bool
src/skimage/measure/_colocalization.py:    image1_mask : (M, N) ndarray of dtype bool
src/skimage/measure/_colocalization.py:    mask : (M, N) ndarray of dtype bool, optional
src/skimage/measure/_regionprops.py:    label_image : (M, N[, P]) ndarray
src/skimage/measure/_regionprops.py:    intensity_image : (M, N[, P][, C]) ndarray, optional
src/skimage/measure/_regionprops.py:    label_image : (M, N[, P]) ndarray
src/skimage/measure/_regionprops.py:    intensity_image : (M, N[, P][, C]) ndarray, optional
```
