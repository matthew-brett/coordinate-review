# Coordinate review

Partially distilled from AI summaries with:

* Gemini — 3
* Claude — Opus 4.5
* Cursor — auto

## Background

Let us imagine a 2D grayscale image.

To be more concrete, let's load such an image:

```{python}
import numpy as np
import skimage as ski

import matplotlib.pyplot as plt

# Set default 2D image colormap.
plt.rc('image', cmap='gray')

img = ski.data.camera()
img.shape
```

Let us now imagine that we want to identify a pixel by its
coordinate.

A coordinate is a pair of numbers identifying the pixel.

For example, we may have a coordinate (5, 10).  To interpret
this coordinate, we need to know what the 5 and 10 refer to.
Put another way, we have to know what *coordinate axes* the
5 and 10 relate to.  The coordinate axes specify a *coordinate
system*.

There are two common coordinate systems in imaging.

## The array coordinate system

The first coordinate system will appear the most obvious to
experienced users of Numpy — is is the array coordinate
system, also know as the *matrix* or *linear algebra*
coordinate system.  We will also call this the "i, j" coordinate system, for reasons that should become clear.

This interprets the first number (here 5) as the *position* along the first axis of the array, and the second number (here 10) as a position along the second axis of the array.

In other words, the pixel at (5, 10), using the array coordinate system, is given by the Numpy operation:

```{python}
img[5, 10]
```

So, in this case, the coordinate system is given by the array
axes.

Here is the `cameraman` image displayed in Matplotlib.

```{python}
plt.imshow(img)
```

Notice that, in terms of the image we have just displayed, the
first axis is top to bottom, starting at 0, and the second
axis is left to right, starting at 0.

We call this the "ij" coordinate system on the basis that "i"
will always refer to the first array axis, and "j" to the
second.  We chose "i" and "j" to have no particular meaning in
terms of the way the image is displayed - to remind us that
this meaning is strictly in terms of the axes of the image
array.

## The imaging coordinate system

There is another common coordinate system in imaging, that we
will call the *imaging coordinate system*, or the "x, y"
coordinate system.

Very confusingly, the first axis in the imaging coordinate system corresponds to the *second* axis in the image array, and the second axis in the imaging coordinate system corresponds to the *first* axis in the image array.

Imagine I have some coordinate (11, 20).  If that is a coordinate in the imaging coordinate system, then the equivalent pixel in that coordinate system is given by:

```{python}
img[20, 11]
```

In terms of the display above, the first axis of the
coordinate system runs from left to right, starting at 0, and
the second axis in the coordinate system runs from top to
bottom, starting at 0.

Why is this *imaging* coordinate system popular?  Because it
matches, in part, the way we think of axes on a graph.  On
a graph, the first axis is *x* and runs from left to right,
and the second is *y* and it runs from bottom to top.  With
images, we often think of the first values in the image as
being at the *top* of the image (not the bottom), so, for the
imaging coordinate convention, it's most common to think of
the y (second) axis as running top to bottom (rather than the
y-axis of standard graphs, which run from bottom to top).

Notice that the labels "x" and "y" refer to the way that the
image is displayed on the screen.

Obviously, in order to know what pixel any coordinate refers
to, we need to know which coordinate system we are using.  The
coordinate (5, 10) means `img[5, 10]` if it's in array
coordinates, and `img[10, 5]` if it's in imaging coordinates.

## Row and columns

For a 2D image, there appears to be no ambiguity in the term
"row" or "column".  Both the "ij" and "xy" convention think of the row of an image as going left to right in the display, and therefore, in terms of the image array, the row at position 5 is given by:

```{python}
# Row at position 5.
row_5 = img[5, :]
```

Columns in both conventions run top to bottom, so the column at position 10 is given by:

```{python}
# Column at position 10.
col_10 = img[:, 10]
```

Thus, for a *2D grayscale array*, we can talk about *row, column* coordinates ("rc" coordinates), where the first axis gives row position, and the second axis give column position.  Of course, *for the 2D case* this is the same as the "ij" convention.

There are various instances in Scikit-image, of coordinate values referring to row and column axes.  `skimage.draw` has many such instances.  Here's the docstring for `skimage.draw.line`:

```python
def line(r0, c0, r1, c1):
    """Generate line pixel coordinates.

    Parameters
    ----------
    r0, c0 : int
        Starting position (row, column).
    r1, c1 : int
        End position (row, column).

    Returns
    -------
    rr, cc : (N,) ndarray of int
        Indices of pixels that belong to the line.
        May be used to directly index into an array, e.g.
        ``img[rr, cc] = 1``.

    ...
    """
```

## Rows and columns in 3D

We've emphasized that the "rc" convention is the same as the "ij" convention for 2D.

Now consider an image with more than two dimensions.

```{python}
img_4d = ski.data.cells3d()
img_4d.shape
```

In fact the first dimension tracks over a third spatial dimension, the second tracks two different things being imaged in the same sample — `img_4d[:, 0]` gives cell membranes, `img[:, 1]` gives cell nuclei.  The third and fourth dimensions are the rows and columns of the 2D images.

Let's first select out the nuclei, to give a 3D image of nuclei:

```{python}
# Select images of nuclei
img_3d = img_4d[:, 1]
img_3d.shape
```

We're going to allow ourselves to sink into confusion for a few paragraphs, so hold on tight.

The first axis is the third spatial axis of the image.   We
might call this axis — the "plane" axis.  We can think of
`img_3d` as containing a series of 2D images stacked on top of
each other, where the first axis selects the plane, the second
the "row" of the image, and third the "column" of the image.

For example, to show the middle plane:

```{python}
middle_i = img_3d.shape[0] // 2
img_2d = img_3d[middle_i, :, :]
plt.imshow(img_2d)
```

Where's the confusion?  Well — for a 2D image, we were happy
to call the first array axis the "row" axis.  It's the row
axis, because that axis represents rows in the displayed
image.  For a 2D image, this is also the "i" axis, because
it's the first axis.

However, now we're in 3D, the first axis is no longer the
"row" axis, because the row axis is the axis representing the
rows in a 2D image.  So we now find ourselves wanting to call
the second axis (of `img_3d`) the "row" axis, if we are
thinking in terms of displayed 2D images.  The "row" axis is
no longer the same as the "i" axis — if anything it is the "j"
axis, where the "column" axis is the "k" axis.

This is to point out that "row" carries a meaning in terms of
how we think of the array, for 2D display.  In our example,
the "row" axis might be the second axis, but then again, it
depends how you think of the 3D image in terms of 2D.  We could also think of `img_3d` as a stack of 2D images, where displayed rows and columns are the first two dimensions, and the third is the last spatial dimension:

```{python}
middle_k = img_3d.shape[2] // 2
another_img_2d = img_3d[:, :, middle_k]
plt.imshow(another_img_2d)
```

So, "row" becomes ambiguous here — the axis we think of as
corresponding to rows, depends on how we think of the image
display.  That is, "row" is a *semantic* label for an axis,
telling us what that axis means.

In contrast, when we use "i", or "j" or "k" to label an axis,
we intend no semantic meaning — we just refer to the first,
second and third axis of an array, regardless of the meaning
of these axes.

## Semantic and not-semantic labels

We will therefore call "row" and "column" and "plane"
*semantic* axis labels, because each tells about what that
particular axis means in terms of image display.

"i", "j" and "k" are non-semantic axis labels, and only refer
to the first second and third axes of the array.

## Convention and semantic labels

In general, in code, when we use "row" or "column" or "plane"
as axis labels, we would like to be able to predict which axes
these refer to, in terms of the image.  The only way we can do
that, short of having an array structure where we can
explicitly label the axes (such as
[xarray](https://docs.xarray.dev), is *by convention*.  That
is, we always make sure that, for example, the "plane" axis is
first, the "row" axis is second, and the "column" axis is
third.

Conventions can differ in different fields.  For example, in
my own (MB) field of brain imaging, the convention is for 3D
brain images to be row first, then columns, then plane, so
"plane", by convention, is the last axis, not the first.

In fact, you can already see conventions for axis positions in
play with 2D color images.  Typically, we represent 2D color
images with the three or four color channels running along the
third axis. That is a typical (by convention) 2D color image
is 3D, with rows as the first dimension, columns as the
second, and color channel as the third.

## Skimage and row, column

I am going to argue that "row" and "column" should always be treated as
semantic labels, in that they refer to the displayed rows and columns of the
image, and the way you display an image is your choice, according to the
meaning of the axes.

But — there may be situations where the semantic meaning,  in practice, always corresponds to axes.  I would argue that the criterion should be:

> a) Does "row" always mean the first axis, in practice?
> b) Does "column" always mean the second axis, in practice?

If so, the use of "row" and "column" is acceptable, and is a synonym for "i"
and "j" in the "i, j" convention.

Otherwise "row" and "column" are generally not acceptable, and need to be
rephrased in terms of "i, j, k ...".

Cursor identified multiple instances of row and column references in docstrings and variables.

## Skimage and planes

Like "row" and "column", "plane" is a semantic label.  I am going to argue
that "plane" should not be used, as it is up the particular field or library,
which axis corresponds to the meaning "plane".   We should replace use of
"plane" in the library with "i, j, k" — i.e. use Numpy axis labels to make the
intention clear.   We should instead specify the plane axis, where necessary,
with a `plane_axis=` keyword argument.



Cursor identified multiple instances of row and column references in docstrings and variables.

## x and y in variables and docstrings

We have various instances of "x" and "y" in signatures, docstrings and code.

Most of the time, "x" means "column" or "j", and "y" means "row" or "i".

In those cases, we should have the following policy:

* Deprecate use of "x" and "y" (when they have meaning "column" and "row"),
  and prefer "i" and "j" (or maybe "column" and "row").  We should also either
  make these keyword-only, or change the default parameter order to prefer
  "i", "j" order rather than "column", "row" order.
* We may want to either:

  a) add an extra keyword argument similar to `coord_convention='xy' | 'ij'` or
  b) recommend `skimage2` version of same function, that uses "ij" by default.

  For compatibility, we will need either the keyword argument (as above) or some helper to explain how to achieve the "x, y" effect using the Skimage2 "i, j" implementation.

### Examples of "x", "y"

* `predict_x`, `predict_y`, `predict_xy` in transform classes.  The transform
  classes use "x" to mean the first column in an n by 2 coordinate array, and
  "y" to mean the second.  And by convention, they are written as if they
  expect the "x" coordinate to be image column coordinates, and "y" to be
  image row coordinates.  However, there is no reason in the code that the
  first column could not be image row coordinates, and the second be image
  column coordinates.  So `predict_x` in fact means, predict coordinate in
  first coordinate column, and so on.  We can therefore rephrase these as `predict_i`, `predict_j`, and `predict_ij`.

* `skimage.feature.corner.structure_tensor` and `hessian_matrix` have an
  `order='rc' | 'xy'` input parameter that default to "rc" (meaning "ij").  Here's the parameter description from the docstring:

  ```rest
    order : {'rc', 'xy'}, optional
        NOTE: 'xy' is only an option for 2D images, higher dimensions must
        always use 'rc' order. This parameter allows for the use of reverse or
        forward order of the image axes in gradient computation. 'rc' indicates
        the use of the first axis initially (Arr, Arc, Acc), whilst 'xy'
        indicates the usage of the last axis initially (Axx, Axy, Ayy).
  ```

  There are currently 6 uses of this `'xy'` option on Github with search
  `/structure_tensor\(.*,.*["']xy["']/  AND NOT path:test_corner.py`
  (to avoid copies of the Skimage test suite).  Five are within `nematic` and
  `NematicTL` repos by `viciya`; one is in a project repo
  `tiagopetena/computer_vision`.  These could be resolved by suitable PRs.  But `/hessian_matrix\(.*,.*["']xy["']/  AND NOT path:test_corner.py` occurs in 41 files, so that would be some work to resolve with PRs.  In neither case is the `order='xy'` case easy to pull out with a helper function.

  Suggest retaining this option in Skimage2, leaving with default `rc`
  behavior.  Perhaps we could deprecate at some later stage.
